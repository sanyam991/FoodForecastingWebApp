# FoodForecastingWebApp

AI-Powered Kitchen: Food Preparation Forecasting
Project Overview
This project presents an "AI-Powered Kitchen" application designed to revolutionize food preparation forecasting and minimize food waste. It combines a robust Spring Boot backend for data-driven forecasting with a dynamic React frontend that offers intuitive user interaction and integrates advanced generative AI features via the Google API.

The core problem addressed is the inefficiency and waste generated by traditional, often manual, methods of food demand prediction in kitchens. By leveraging historical data and AI, the application aims to optimize preparation quantities, suggest creative culinary solutions, and promote sustainable practices.

Technologies Used
Frontend: React, Tailwind CSS

Backend: Spring Boot (Java 17, Maven)

AI Integration: Google Gemini API 

Containerization: Docker, Docker Compose

Features
Food Demand Forecasting (Backend-driven):

Predicts optimal food preparation quantities based on historical data, event types, audience profiles, and footfall patterns.

Aims to dynamically adjust quantities to minimize over-preparation and food waste.

Recipe Suggestions (AI-powered):

Generates tailored recipe ideas or meal components based on forecasted quantities, event type, and audience profile, leveraging the Gemini API.

Ingredient Substitution Ideas (AI-powered):

Provides alternative ingredient suggestions for specific ingredients, considering dietary restrictions, availability, or cost-saving, powered by the Gemini API.

Leftover Utilization Ideas (AI-powered):

Offers creative and practical suggestions for utilizing potential leftovers, promoting a zero-waste approach, powered by the Gemini API.

Intuitive User Interface: A clean and responsive React UI for seamless interaction.

Robust Backend: A Spring Boot REST API handles the core forecasting logic and data processing.

Architecture
The application follows a microservices-like architecture with a clear separation of concerns between the frontend and backend.


Frontend (React App): Serves as the user interface. It collects event details, displays forecasts, and directly interacts with the Google Gemini API for generative AI features. It communicates with the Spring Boot backend for the core forecasting.

Backend (Spring Boot): Provides a RESTful API endpoint for food demand forecasting. It receives event details and historical data from the frontend, processes them using its forecasting logic (currently rule-based, extensible for ML models), and returns the predicted quantities.

Google Gemini API: A powerful Large Language Model (LLM) that the frontend directly calls to generate creative content like recipe suggestions, ingredient substitutions, and leftover utilization ideas based on dynamic prompts.

Database (Future Enhancement): Planned for persistent storage of historical data, user preferences, and inventory.

Setup and Running Instructions
Prerequisites
Before you begin, ensure you have the following installed:

Node.js & npm: https://nodejs.org/ (LTS version recommended)

Java Development Kit (JDK): Version 17 or higher. https://www.oracle.com/java/technologies/downloads/

Maven: https://maven.apache.org/download.cgi

Docker Desktop: https://www.docker.com/products/docker-desktop/

Google Gemini API Key: Obtain one from https://aistudio.google.com/app/apikey

1. Clone the Repository
First, clone this project to your local machine:

git clone https://github.com/your-repo/food-forecast-project.git # Replace with your actual repo URL
cd food-forecast-project

2. Frontend Setup (frontend/)
Navigate into the frontend directory:

cd frontend

Install Dependencies:

npm install

Configure Tailwind CSS:

Ensure Tailwind CSS is correctly initialized. If tailwind.config.js and postcss.config.js are not present, run:

npx tailwindcss init -p

Then, ensure your tailwind.config.js content array includes ./src/**/*.{js,jsx,ts,tsx} and ./public/index.html. Also, add the Tailwind directives (@tailwind base;, @tailwind components;, @tailwind utilities;) to the top of src/index.css.


3. Backend Setup (backend/)
Navigate into the backend directory:

cd ../backend

Build the Project:

mvn clean install

4. Running the Application with Docker Compose (Recommended)
This is the easiest way to run both the frontend and backend together.

Ensure Docker Desktop is running.

Navigate back to the project root directory:

cd .. # if you are in backend/, otherwise ensure you are in food-forecast-project/

Build the Docker images:

docker-compose build

Run the containers:

docker-compose up -d

This will start both services in the background.

Access the Application:

Frontend: Open your web browser and go to http://localhost:3000

Backend API (for testing): The backend will be accessible at http://localhost:8080 (though the frontend handles calls to it).

To Stop the Containers:

docker-compose down

5. Running Locally (Alternative)
If you prefer not to use Docker Compose, you can run each service separately:

Start the Backend:

Navigate to backend/

Run: mvn spring-boot:run

The backend will start on http://localhost:8080.

Start the Frontend:

Open a new terminal window.

Navigate to frontend/

Run: npm start

The frontend will open in your browser, usually at http://localhost:3000.

Future Enhancements
Advanced Machine Learning Model: Integrate a more sophisticated ML model (e.g., ARIMA, Prophet, Neural Networks) for forecasting.

Database Integration: Implement a persistent database (e.g., PostgreSQL, MySQL, Firestore) for storing actual historical data, user preferences, and inventory.

Inventory Management System: Track current ingredient inventory, suggest optimal purchasing, and alert for low stock.

User Profiles & Customization: Allow users to create profiles, save data, and customize preferences.

Feedback Loop Implementation: Implement a system for users to input actual consumption data for model retraining.

Mobile Application: Develop native iOS/Android apps for on-the-go access.

Reporting & Analytics Dashboard: Visualizations of forecasting accuracy and waste reduction.

Integration with POS/ERP Systems: Seamlessly connect with existing systems for automated data flow.

Cost Optimization Analysis: Provide insights into cost savings.

Contact
Sanyam Sachan
Email - sachansanyam203@gmail.com
